#include "AnvLog.h"

namespace anv_log
{
	struct File
	{
		File(const std::string _path)
		{
			m_Path = _path;
			CheckExists();
			Write("=================================================================\n");
			Write("== THIS FILE AND ITS CONTENTS WERE GENERATED BY THE ANVLOG LIB ==\n");
			Write("=================================================================\n");
		}

		void Write(std::string _content)
		{
			auto file = std::fstream(m_Path, std::ios::app);
			if (!file)
			{
				std::cout << "LogError: Failed to open log file for output: " << m_Path << '\n';
				return;
			}

			file << _content;
			file.close();
		}

		void CheckExists()
		{
			if (!std::filesystem::exists(m_Path)) {
				std::ofstream newFile(m_Path);
				if (!newFile)
				{
					std::cout << "Failed to find and create file: " << m_Path << '\n';
				}
			}

			// Clear files contents and close
			std::ofstream clearFile(m_Path, std::ios::out | std::ios::trunc);
			clearFile.close();
		}

	private:
		std::string m_Path;
	};

	void AnvLog::Init(const LogCreateInfo _info)
	{
		m_CreationInfo = _info;
		if (_info.fileOutput)
		{
			m_File = std::make_unique<File>(_info.logFilePath);
		}
	}

	void AnvLog::LOG_CUST(TermColor _col, LogLevel _lev, const std::string _str, ...)
	{
		va_list args;
		va_start(args, _str);

		// Format the message
		std::string formattedMessage = formatString(_str, args);

		std::stringstream out;
		out << GetTime();
		out << level_to_string(_lev);
		out << formattedMessage;

		if (m_CreationInfo.fileOutput)
		{
			m_File->Write(out.str() + "\n");
		}

		if (m_CreationInfo.consoleOutput)
		{
			std::cout << color_to_string(_col) << out.str() << COLOR_CLEAR << '\n';
		}

		va_end(args);
	}

	void AnvLog::LOG_INFO(const std::string _str, ...)
	{
		va_list args;
		va_start(args, _str);

		// Format the message
		std::string formattedMessage = formatString(_str, args);

		std::stringstream out;
		out << GetTime();
		out << "[INFO]: ";
		out << formattedMessage;

		if (m_CreationInfo.fileOutput)
		{
			m_File->Write(out.str() + "\n");
		}

		if (m_CreationInfo.consoleOutput)
		{
			std::cout << COLOR_GREEN << out.str() << COLOR_CLEAR << '\n';
		}

		va_end(args);
	}

	void AnvLog::LOG_DEBUG(const std::string _str, ...)
	{
		va_list args;
		va_start(args, _str);

		// Format the message
		std::string formattedMessage = formatString(_str, args);

		std::stringstream out;
		out << GetTime();
		out << "[DEBUG]: ";
		out << formattedMessage;

		if (m_CreationInfo.fileOutput)
		{
			m_File->Write(out.str() + '\n');
		}

		if (m_CreationInfo.consoleOutput)
		{
			std::cout << COLOR_BLUE << out.str() << COLOR_CLEAR << '\n';
		}

		va_end(args);
	}

	void AnvLog::LOG_WARN(const std::string _str, ...)
	{
		va_list args;
		va_start(args, _str);

		// Format the message
		std::string formattedMessage = formatString(_str, args);

		std::stringstream out;
		out << GetTime();
		out << "[WARN]: ";
		out << formattedMessage;

		if (m_CreationInfo.fileOutput)
		{
			m_File->Write(out.str() + '\n');
		}

		if (m_CreationInfo.consoleOutput)
		{
			std::cout << COLOR_YELLOW << out.str() << COLOR_CLEAR << '\n';
		}

		va_end(args);
	}

	void AnvLog::LOG_ERROR(const std::string _str, ...)
	{
		va_list args;
		va_start(args, _str);

		// Format the message
		std::string formattedMessage = formatString(_str, args);

		std::stringstream out;
		out << GetTime();
		out << "[ERROR]: ";
		out << formattedMessage;

		if (m_CreationInfo.fileOutput)
		{
			m_File->Write(out.str() + '\n');
		}

		if (m_CreationInfo.consoleOutput)
		{
			std::cout << COLOR_RED << out.str() << COLOR_CLEAR << '\n';
		}

		va_end(args);
	}

	void AnvLog::LOG_FATAL(const std::string _fn, const std::string _str, ...)
	{
		va_list args;
		va_start(args, _str);

		// Format the message
		std::string formattedMessage = formatString(_str, args);

		std::stringstream out;
		out << GetTime();
		out << "[FATAL]";
		out << "[" << _fn << "]";
		out << formattedMessage;

		if (m_CreationInfo.fileOutput)
		{
			m_File->Write(out.str() + '\n');
		}

		if (m_CreationInfo.consoleOutput)
		{
			std::cout << COLOR_RED << out.str() << COLOR_CLEAR << '\n';
		}

		va_end(args);

		std::abort();
	}

	// returns a time formatted by the users pref
	std::string AnvLog::GetTime()
	{
		auto now = std::chrono::system_clock::now();
		std::time_t current = std::chrono::system_clock::to_time_t(now);

		std::string format = m_CreationInfo.timeFormat;
		std::stringstream ss = {};

		ss << "[";
		ss << std::put_time(std::localtime(&current), format.c_str());
		ss << "]";

		return ss.str();
	}

	std::string AnvLog::formatString(const std::string& format, va_list args)
	{
		char buffer[1024];
		vsnprintf(buffer, sizeof(buffer), format.c_str(), args);
		return std::string(buffer);
	}

	std::string AnvLog::level_to_string(const LogLevel _lev)
	{
		switch (_lev)
		{
		case LogLevel::LL_NONE:
			return " ";
			break;
		case LogLevel::LL_INFO:
			return "[INFO]: ";
			break;
		case LogLevel::LL_DEBUG:
			return "[DEBUG]: ";
			break;
		case LogLevel::LL_WARN:
			return "[WARN]: ";
			break;
		case LogLevel::LL_ERROR:
			return "[ERROR]: ";
			break;
		case LogLevel::LL_FATAL:
			return "[FATAL]: ";
			break;
		default:
			return "";
			break;
		}
	}
	std::string AnvLog::color_to_string(const TermColor _col)
	{
		switch (_col)
		{
		case TermColor::TC_NONE:
			return COLOR_CLEAR;
			break;
		case TermColor::TC_BLACK:
			return COLOR_BLACK;
			break;
		case TermColor::TC_RED:
			return COLOR_RED;
			break;
		case TermColor::TC_GREEN:
			return COLOR_GREEN;
			break;
		case TermColor::TC_YELLOW:
			return COLOR_YELLOW;
			break;
		case TermColor::TC_BLUE:
			return COLOR_BLUE;
			break;
		case TermColor::TC_MAGENTA:
			return COLOR_MAGE;
			break;
		case TermColor::TC_CYAN:
			return COLOR_CYAN;
			break;
		default:
			break;
		}
	}
}